/*
 *                    BioJava development code
 *
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public Licence.  This should
 * be distributed with the code.  If you do not have a copy,
 * see:
 *
 *      http://www.gnu.org/copyleft/lesser.html
 *
 * Copyright for this code is held jointly by the individual
 * authors.  These should be listed in @author doc comments.
 *
 * For more information on the BioJava project and its aims,
 * or to join the biojava-l mailing list, visit the home page
 * at:
 *
 *      http://www.biojava.org/
 *
 * Created on 21.03.2004
 * @author Andreas Prlic
 *
 */
package org.biojava.spice.Panel;

import org.biojava.spice.SPICEFrame  	   	;

// biojava stuff
import org.biojava.bio.gui.sequence.SequencePanel;
import org.biojava.bio.seq.Sequence;
import org.biojava.bio.seq.ProteinTools;
import org.biojava.bio.seq.FeatureFilter;
import org.biojava.bio.symbol.* ;
import org.biojava.utils.ChangeVetoException;
import org.biojava.bio.gui.sequence.*;

// to get icons...
import org.biojava.spice.SpiceApplication;
import org.biojava.spice.Feature.Feature;
import org.biojava.spice.Feature.Segment;
import org.biojava.spice.GUI.SelectionLockMenuListener;
import org.biojava.spice.GUI.SelectionLockPopupListener;
import org.biojava.bio.Annotation;
import org.biojava.bio.SimpleAnnotation;

//import org.biojava.spice.Feature.*     	;
import org.biojava.spice.Panel.SeqPanel	;
import org.biojava.spice.Panel.seqfeat.Line;
import org.biojava.bio.structure.Chain 	;
import org.biojava.bio.structure.Group  	;


import java.awt.Color                     ;
import java.awt.Graphics                  ;
import java.awt.image.BufferedImage       ;
import java.awt.Font                      ;
import java.awt.Dimension                 ;

import java.awt.event.ActionListener;
import java.awt.event.MouseListener       ; 
import java.awt.event.MouseMotionListener ;
import java.awt.event.MouseEvent          ;
import java.awt.Graphics2D                ;
import java.awt.* ;



import java.util.List                     ;
import java.util.ArrayList                ;

import java.util.Date        ;

import java.util.logging.*   ;
import javax.swing.ImageIcon;
import javax.swing.JMenuItem;
import javax.swing.JPanel    ;
import javax.swing.JPopupMenu;

import java.util.regex.*;


import java.util.Iterator;


//import ToolTip.* ;

/**
 * A class the provides a graphical reqpresentation of the Features of a protein sequences. Requires an arraylist of features.
 @author Andreas Prlic
 */
public class SeqFeaturePanel 
extends SequencePanel 
implements SeqPanel, MouseListener, MouseMotionListener

{      
    public static final int    DEFAULT_X_START        = 60  ;
    public static final int    DEFAULT_X_RIGHT_BORDER = 20 ;
    public static final int    DEFAULT_Y_START        = 30 ;
    public static final int    DEFAULT_Y_STEP         = 10 ;
    public static final int    DEFAULT_Y_HEIGHT       = 4 ;
    public static final int    DEFAULT_Y_BOTTOM       = 16 ;
    
    // the line where to draw the structure
    public static final int    DEFAULT_STRUCTURE_Y    = 20 ;
    public static final int    TIMEDELAY              = 300 ;
    
    public static final Color SELECTION_COLOR         = Color.lightGray;
    public static final Color STRUCTURE_COLOR         = Color.red;
    public static final Color STRUCTURE_BACKGROUND_COLOR = new Color(0.5f, 0.1f, 0.5f, 0.5f);
    
    // use this font for the text
    public static final Font plainFont = new Font("SansSerif", Font.PLAIN, 10);
    
    static Cursor handCursor = new Cursor(Cursor.HAND_CURSOR);
    static Cursor defaultCursor = new Cursor(Cursor.DEFAULT_CURSOR);
    
    JPopupMenu popupMenu ;
    
    int selectStart ;
    int selectEnd      ;
    int mouseDragStart ;
    // the master application
    SPICEFrame spice ;
    
    
    Color seqColorOld ;
    Color strucColorOld ;
    
    Chain chain      ;
    int current_chainnumber;

     
    float scale ;
    
    List drawLines ;
    ArrayList knownLinks;

    Date lastHighlight ;
 
      
    Image xml_img;
    Image x_img;
    Image updown_img;
    
    Logger logger;
    
    Pattern dassourcePattern;
    MultiLineRenderer multiLineRenderer;
    BumpedRenderer bumpR;
    /**
     * 
     */
    public SeqFeaturePanel(SPICEFrame spicefr ) {
        super();
        logger = Logger.getLogger("org.biojava.spice");
        setDoubleBuffered(true) ;
        
        // TODO Auto-generated constructor stub
        Dimension dstruc=this.getSize();
        
        spice = spicefr;
        //features = new ArrayList();
        drawLines = new ArrayList();
        knownLinks = new ArrayList();
        chain = null ;
                
        lastHighlight = new Date();
        
        current_chainnumber = -1 ;
        
        setOpaque(true);
                
        selectStart    = -1 ;
        selectEnd      =  1 ;
        mouseDragStart = -1 ;
        
        popupMenu = new JPopupMenu();
        
        SelectionLockMenuListener ml = new SelectionLockMenuListener(spice);
        
        JMenuItem menuItem = new JMenuItem("Lock Selection");
        menuItem.addActionListener(ml);
        popupMenu.add(menuItem);
        //menuItem = new JMenuItem("delete");
        //menuItem.addActionListener(ml);
        //tablePopup.add(menuItem);
        
        
        MouseListener popupListener = new SelectionLockPopupListener(popupMenu,spice);
        this.addMouseListener(popupListener);
      
        ImageIcon xml_icon     = createImageIcon("xml_icon.png");
        if ( xml_icon != null)
            xml_img = xml_icon.getImage();    
        else
            xml_img = null;
        
        ImageIcon x_icon       = createImageIcon("x_icon.png");        
        if (x_icon != null)
            x_img = x_icon.getImage();
        else
            x_img = null;
        
        ImageIcon updown_icon  = createImageIcon("updown_icon.png");
        if ( updown_icon != null)
            updown_img=updown_icon.getImage();
        else
            updown_img = null;
     
        dassourcePattern = Pattern.compile("http:..([a-zA-Z0-9\\.-_]+).*");
           
        multiLineRenderer = new MultiLineRenderer();
        //MultiLineRenderer mlr = new MultiLineRenderer();
        FeatureRenderer featr = new BasicFeatureRenderer();
        SequenceRenderer seqR = new SymbolSequenceRenderer();
        FeatureBlockSequenceRenderer fbr = new FeatureBlockSequenceRenderer();
        bumpR = new BumpedRenderer(fbr);
        
//      FeatureFilter ff      = new FeatureFilter.BySource();
        //FilteringRenderer filtR  = new FilteringRenderer();
        
        try {
//      Register the FeatureRenderer with the FeatureBlockSequenceRenderer
        fbr.setFeatureRenderer(featr);
        //filtR.setRenderer(bumpR);
        
        //add Renderers to the MultiLineRenderer
        //mlr.addRenderer(fbr);
        //mlr.addRenderer(filtR);
        multiLineRenderer.addRenderer(seqR);
        

        //set the MultiLineRenderer as the SequencePanels renderer
        this.setRenderer(multiLineRenderer);
        // default display first 100 aminos...
        this.setRange(new RangeLocation(1,100));
        } catch (Exception e){
            logger.warning(e.getMessage());
        }
    }
    
    public void lockSelection(){
        spice.setSelectionLocked(true);
    }
    public void unlockSelection(){
        spice.setSelectionLocked(false);
    }
    
    /** Returns an ImageIcon, or null if the path was invalid. */
    private ImageIcon createImageIcon(String path) {
        java.net.URL imgURL = SpiceApplication.class.getResource(path);
        if (imgURL != null) {
            return new ImageIcon(imgURL);
        } else {
            //logger.log(Level.WARNING,"Couldn't find file: " + path);
            logger.warning("Couldn't find file: " + path);
            return null;
        }
    }
    
    //public void paintComponent( Graphics g) {
      //super.paintComponent(g);
    //}
    
    /** returns the size of one amino acid in the display; in pixel */
    public int getAminoSize(){
        return Math.round(1 * scale) ;
    }
    
    
    public void scale(Dimension dstruc){
        
        int chainlength =chain.getLength() ;
        scale = (dstruc.width ) / (float)(DEFAULT_X_START + chainlength + DEFAULT_X_RIGHT_BORDER ) ;
        
    }
    
    /** draw structrure covered region as feature */
    private void drawStructureRegion(Graphics2D g2D, int aminosize){
        // data is coming from chain;
        
        g2D.drawString("Structure",1,DEFAULT_STRUCTURE_Y+DEFAULT_Y_HEIGHT);
        
        int start = -1;
        int end   = -1;
        
        for ( int i=0 ; i< chain.getLength() ; i++ ) {
            Group g = chain.getGroup(i);
            
            if ( g.size() > 0 ){
                if ( start == -1){
                    start = i;
                }
                end = i;
            } else {
                if ( start > -1) {
                    drawStruc(g2D,start,end,aminosize);
                    start = -1 ;
                }
            }
        }
        // finish
        if ( start > -1) 
            drawStruc(g2D,start,end,aminosize);
        
    }
    private void drawStruc(Graphics2D g2D, int start, int end, int aminosize){
        //System.out.println("Structure " + start + " " + end);
        int y = DEFAULT_STRUCTURE_Y ;
        
        int xstart = java.lang.Math.round(start * scale) + DEFAULT_X_START;
        int endx   = java.lang.Math.round(end * scale)-xstart + DEFAULT_X_START +aminosize;
        int width  = aminosize ;
        int height = DEFAULT_Y_HEIGHT ;
        
        // draw the red structure line
        g2D.setColor(STRUCTURE_COLOR);	
        g2D.fillRect(xstart,y,endx,height);
        
        // highlite the background
        Composite origComposite = g2D.getComposite();
        g2D.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,0.8f));
        g2D.setColor(STRUCTURE_BACKGROUND_COLOR);
        Dimension dstruc=this.getSize();
        Rectangle strucregion = new Rectangle(xstart , 0, endx, dstruc.height);
        g2D.fill(strucregion);
        g2D.setComposite(origComposite);
    }
    
    /** draw a line representing a sequence
     * returns the scaled length of the sequence */
    public  int drawSequence(Graphics2D g2D, float chainlength){
        g2D.setColor(Color.white);
        int seqx = java.lang.Math.round(chainlength * scale) ;
        g2D.drawString("Sequence",1,10+DEFAULT_Y_HEIGHT);
        g2D.fillRect(0+DEFAULT_X_START, 10, seqx, 6);
        return seqx ;
    }
    
    /** draw the Scale */
    public void drawScale(Graphics2D g2D, int chainlength){
        g2D.setColor(Color.GRAY);
        
        for (int i =0 ; i< chainlength ; i++){
            if ( (i%100) == 0 ) {
                int xpos = Math.round(i*scale)+DEFAULT_X_START ;
                g2D.fillRect(xpos, 0, 1, 8);
            }else if  ( (i%50) == 0 ) {
                int xpos = Math.round(i*scale)+DEFAULT_X_START ;
                g2D.fillRect(xpos, 0, 1, 6);
            } else if  ( (i%10) == 0 ) {
                int xpos = Math.round(i*scale)+DEFAULT_X_START ;
                g2D.fillRect(xpos, 0, 1, 4);
            }
        }
    }
    
    /** draw the selected region */
    public void drawSelection(Graphics2D g2D, int aminosize, int seqx){
        
        
        if ( selectStart > -1 ) {
            Dimension dstruc=this.getSize();
            g2D.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,0.8f));        
            
            g2D.setColor(SELECTION_COLOR);
            seqx = java.lang.Math.round(selectStart*scale)+DEFAULT_X_START ;
            
            int selectEndX = java.lang.Math.round(selectEnd * scale)-seqx + DEFAULT_X_START +aminosize; 
            if ( selectEndX < aminosize) 
                selectEndX = aminosize ;
            
            if ( selectEndX  < 1 )
                selectEndX = 1 ;
            
            Rectangle selection = new Rectangle(seqx , 0, selectEndX, dstruc.height);
            g2D.fill(selection);
            
        }
    }
    
    
    
    
    
    /** draw the features */
    public void drawFeatures(Graphics2D g2D, int aminosize){
        int y = DEFAULT_Y_START ;
        drawFeatures(g2D,aminosize,y);
    }
    /** draw the features starting at position y
     * returns the y coordinate of the last feature ;
     * */
    public int drawFeatures(Graphics2D g2D, int aminosize, int y){
        //logger.finest("number features: "+features.size());
        //System.out.println("seqFeatCanvas aminosize "+ aminosize);
        Dimension dim = this.getSize();
        boolean secstruc = false ;
        
        for (int i = 0 ; i< drawLines.size();i++) {
            //logger.finest(i%entColors.length);
            //g2D.setColor(entColors[i%entColors.length]);
            
            y = y + DEFAULT_Y_STEP ;
            
            Line currentLine = (Line)drawLines.get(i);
            List features = currentLine.getFeatures(); ;
            
            for ( int f =0 ; f< features.size();f++) {
                
                org.biojava.spice.Feature.Feature feature = 
                    (org.biojava.spice.Feature.Feature) features.get(f);
                
                // line separator
                
                if ( feature.getMethod().equals("_SPICE_LINESEPARATOR")) {
                    //logger.finest("_SPICE_LINESEPARATOR");
                   
                    g2D.setColor(Color.GRAY );   
                    
                    // modification icons
                    Rectangle line = new Rectangle(DEFAULT_X_START,y,dim.width,1);
                    g2D.fill(line);
                    
                                    
                    g2D.fill(new Rectangle(0,y,14,16));
                    g2D.fill(new Rectangle(16,y,20,16));
                    g2D.fill(new Rectangle(22,y,14,16));
                    
                    if (updown_img != null)                       
                        g2D.drawImage(updown_img,0,y,this);                    
                    if (xml_img != null)
                        g2D.drawImage(xml_img,+16,y,this);
                    if ( x_img != null) 
                        g2D.drawImage(x_img,44,y,this);
                    
                    String ds = getDisplayString(feature);
                    g2D.setColor(Color.white);
                                        
                    g2D.drawString(ds,DEFAULT_X_START,y+DEFAULT_Y_HEIGHT+6);
                    y+=10;
                    
                    continue ;
                }
                
                List segments = feature.getSegments() ;
                
                // draw text
                if ( segments.size() < 1) {
                    //logger.finest(feature.getMethod());
                    continue ;
                }
                org.biojava.spice.Feature.Segment seg0 = (org.biojava.spice.Feature.Segment) segments.get(0) ;
                Color col =  seg0.getColor();	
                g2D.setColor(col);
                
                g2D.drawString(feature.getName(), 1,y+DEFAULT_Y_HEIGHT);
                
                for (int s=0; s<segments.size();s++){
                    org.biojava.spice.Feature.Segment segment=(org.biojava.spice.Feature.Segment) segments.get(s);
                    
                    int start     = segment.getStart()-1 ;
                    int end       = segment.getEnd()  -1 ;
                    
                    col = segment.getColor();
                    g2D.setColor(col);
                    
                    int xstart =  java.lang.Math.round(start * scale) + DEFAULT_X_START;
                    int width   = java.lang.Math.round(end * scale) - xstart +  DEFAULT_X_START+aminosize ;
                    
                    int height = DEFAULT_Y_HEIGHT ;
                    //logger.finest(feature+ " " + end +" " + width);
                    //logger.finest("color"+entColors[i%entColors.length]);
                    //logger.finest("new feature  ("+i+"): x1:"+ xstart+" y1:"+y+" width:"+width+" height:"+height);
                    String type = feature.getType() ;
                    if (  type.equals("DISULFID")){
                        
                        g2D.fillRect(xstart,y,aminosize,height);
                        g2D.fillRect(xstart,y+(height/2),width,1);
                        g2D.fillRect(xstart+width-aminosize,y,aminosize,height);
                    } else {
                        g2D.fillRect(xstart,y,width,height);
                    }
                }
            }
        }   
        return y ;
    }
    
    private String getDisplayString(org.biojava.spice.Feature.Feature f){	 
        String ds = f.getSource();
        String displayString;
        Matcher m = dassourcePattern.matcher(ds);
        if (m.matches()){
            return m.group(0);
        }
        if (ds.length()>30) {
            displayString = ds.substring(7,17)+"..."+ds.substring(ds.length()-10,ds.length());
        } else
            displayString = ds;
        return displayString;
}
    
    /** get the features as they have been returned from the FeatureFetcher and
     * convert them into the way they are represented here.
     * 
     * currently spice uses a Biojava Sequence object to attach and display the features.
     * paintComponent then takes the Sequence objects and sends it to a biojava renderer.
     * 
     * @param feats
     */
    public void setFeatures( List feats) {
        
        if  ( chain == null   ) return ;
        String sequence = chain.getSequence();
        if ( sequence == null) return;
        System.out.println("got sequence >" +sequence+"<");
        //create a Protein sequence with the name prot_1
        Sequence prot;
        try {
            
            prot = ProteinTools.createProteinSequence(sequence, "prot_1");
        }
        catch (IllegalSymbolException e){
            // can not convert sequence!
            logger.warning(e.getMessage());
            return;
        }
        
        org.biojava.bio.seq.Feature.Template temp = new org.biojava.bio.seq.Feature.Template();
        temp.source = "";
        temp.type = "";
        String oldsource = "";
        for (int i=0; i< feats.size(); i++) {
            org.biojava.spice.Feature.Feature feat = (org.biojava.spice.Feature.Feature)feats.get(i);
            
            // add link to popupmenu
            String link = feat.getLink();
            if ( link != null) {
                registerLinkMenu(feat);
            }
            
            
            String source = feat.getSource();
            temp.source=source;
            if (! source.equals(oldsource)){
                oldsource = source;
                FilteringRenderer filtR = new FilteringRenderer();
                try {
                    filtR.setRenderer(bumpR);
                    FeatureFilter ff = new FeatureFilter.BySource(source); 
                    System.out.println("filtering by "+source);
                    filtR.setFilter(ff);
                    SimpleLabelRenderer labelR = new SimpleLabelRenderer();
                    labelR.setLabel(feat.getName());
                    //multiLineRenderer.addRenderer(labelR);
                    
                    StackedFeatureRenderer stackR = new StackedFeatureRenderer();
                    stackR.addRenderer(labelR);
                    stackR.addRenderer(filtR);
                    multiLineRenderer.addRenderer(stackR);
                } catch ( Exception e) {
                    logger.warning(e.getMessage());
                    e.printStackTrace();
                   
                    continue;
                }
          
            }
            
            temp.type=feat.getType();
            Annotation anno = new SimpleAnnotation();
            try {
                anno.setProperty("name",feat.getName());
            } catch (Exception e){
                logger.warning(e.getMessage());
            }
            temp.annotation = anno;
            List segments = feat.getSegments();
            for ( int s =0; s< segments.size();s++){
                org.biojava.spice.Feature.Segment segment = 
                    (org.biojava.spice.Feature.Segment) segments.get(s);
               int start = segment.getStart();
               int end = segment.getEnd();
               
                
                Location l = new RangeLocation(start,end);
                temp.location = l;
                org.biojava.bio.seq.Feature f ;
                try {
                    f= prot.createFeature(temp);
                } catch (Exception e){
                    logger.warning(e.getMessage());
                }
                
            }
        }
//      set the Sequence to Render
        this.setSequence(prot);

        //display the whole Sequence
        this.setRange(new RangeLocation(1,prot.length()));

      
        //this.repaint();
        
    }
    
    private void registerLinkMenu(Feature feat){
        String link = feat.getLink();
        //  add link to the menu
        //ActionListener ml = new LinkMenuListener(spice,link);
        if ( knownLinks.contains(link))
            return;
        //System.out.println("adding menu:" + link);
        ActionListener ml = new SelectionLockMenuListener(spice);
        JMenuItem menuItem = new JMenuItem("open in browser "+ feat.getName());
        menuItem.addActionListener(ml);
        popupMenu.add(menuItem);
        knownLinks.add(link);
        
    }
    
    private void clearOldLinkMenus(){
        int nr = popupMenu.getComponentCount();
        for ( int i = nr-1; i > 0; i--){
            popupMenu.remove(i);
        }
        knownLinks = new ArrayList();
    }
    
    
    
    /** return height of image. dpends on number of features! */
    
    private int getImageHeight(){
        //int h = DEFAULT_Y_START + drawLines.size() * DEFAULT_Y_STEP + DEFAULT_Y_BOTTOM; 
        //logger.finest("setting height " + h);
        Dimension d = this.getSize();
        return d.height ;
    }
    
    
    
    public void setChain(Chain c,int chainnumber) {
        chain = c;
        current_chainnumber = chainnumber ;
        //this.paintComponent(this.getGraphics());
        this.repaint();
    }
    
    
   
    
    /** highlite a single segment */
    private void highliteSegment (org.biojava.spice.Feature.Segment segment) {
        //logger.finest("highlite Segment");
        //logger.finest("segment");
        
        // clicked on a segment!
        String col =  segment.getTxtColor();
        //seqColorOld = col ;
        //spice.setOldColor(col) ;
        
        
        int start = segment.getStart();
        int end   = segment.getEnd()  ;
        start = start -1 ;
        end   = end   -1 ;
        String type =  segment.getParent().getType() ;
        //logger.finest(start+" " + end+" "+type);
        //logger.finest(segment);
        if ( type.equals("DISULFID")){
            spice.highlite(current_chainnumber,start);
            spice.highlite(current_chainnumber,end);
            
            String pdb1 = spice.getSelectStrSingle(current_chainnumber,start);
            String pdb2 = spice.getSelectStrSingle(current_chainnumber,end);
            String cmd = "select "+pdb1 +", " + pdb2 + "; spacefill on; colour cpk;" ;
            
            spice.executeCmd(cmd);
            
            
        } else if (type.equals("METAL") ){
            spice.highlite(current_chainnumber,start+1,end+1  ,"cpk");
            
        } else if ( type.equals("MSD_SITE") || 
                type.equals("snp")      		  
        ) {
            spice.highlite(current_chainnumber,start+1,end+1  ,"wireframe");	    
        } else if ( (end - start) == 0 ) {
            // feature of size 1
            spice.highlite(current_chainnumber,start+1,start+1  ,"cpk");	     
        } else {
            spice.colour(current_chainnumber,start+1  ,end+1  ,col);	    
        }
        
    }
    
    /** highlite all segments of a feature */
    private String highliteFeature(Feature feature){
        //logger.finest("highlite feature " + feature);
        //Feature feature = (Feature) features.get(featurenr) ;
        //logger.finest("highlite feature " + feature);
      
        
        List segments = feature.getSegments() ;
        String cmd = "" ;
        
        for ( int i =0; i< segments.size() ; i++ ) {
            Segment segment = (Segment) segments.get(i);
            //highliteSegment(segment);
            
            int start = segment.getStart();
            int end   = segment.getEnd();
            //logger.finest("highilte feature " +featurenr+" " + start + " " +end );
            
            if ( feature.getType().equals("DISULFID")){
                cmd += spice.getSelectStr(current_chainnumber,start-1);
                cmd += "colour cpk; spacefill on;";
                cmd += spice.getSelectStr(current_chainnumber,end-1);
                cmd += "colour cpk; spacefill on;";
                
            } else {
                cmd += spice.getSelectStr(current_chainnumber,start,end);
                String col = segment.getTxtColor();
                cmd += "color "+ col +";";
            } 
            //if ( start == end ) {
            //cmd += " spacefill on;";
            //}
        }
        if ( ( feature.getType().equals("METAL")) ||
                ( feature.getType().equals("SITE"))  ||
                ( feature.getType().equals("ACT_SITE")) 	     
        ){
            cmd += " spacefill on; " ;
        } else if ( feature.getType().equals("MSD_SITE")|| 
                feature.getType().equals("snp") 
        ) {
            cmd += " wireframe on; " ;
        }
        
        //logger.finest("cmd: "+cmd); 
        return cmd ;
        
        
    }
    
    
    /** select single position
     select a position
     */
    public void select(int seqpos){	
        // should be done at spice level
        //if ( spice.isSelectionLocked() ) return;
        highlite(seqpos);
        
    }
    
    /** select range */
    public void select(int start, int end) {
        //if ( spice.isSelectionLocked() ) return;
        highlite(start,end);
    }
    
    
    /** same as select here. draw a line at current seqence position
     * only if chain_number is currently being displayed
     */
    public void highlite( int seqpos){
        if  ( chain == null   ) return ;
        //if 	(selectionLocked) return;
        
        if ( seqpos > chain.getLength()) 
            return ;
        selectStart  = seqpos ;
        selectEnd    = 1     ;
        
        this.repaint();
        
    }
    
    /** highlite a region */
    public void highlite( int start , int end){
        if  ( chain == null   ) return ;
        //if (selectionLocked) return ;
        if ( (start > chain.getLength()) || 
                (end   > chain.getLength())
        ) 	      
            return ;
        
        selectStart = start  ;
        selectEnd   = end    ;
        
        this.repaint();
        
    }
    
    
    
    /* check if the mouse is over a feature and if it is 
     * return the feature number 
     * @author andreas
     *
     * To change the template for this generated type comment go to
     * Window - Preferences - Java - Code Generation - Code and Comments
     */
    private int getLineNr(MouseEvent e){
        int mouseY = e.getY();
        int mouseX = e.getX();
        
        Iterator i = drawLines.iterator();
        int pos = -1 ;
        while (i.hasNext()){
            pos++;
            
            Line line = (Line) i.next();
            if ( line.dotInRange(mouseX,mouseY))
                return pos;
        }
        
        return -1;
        
    }
    
    private Feature getFeatureAt(int seqpos, int lineNr){
        //logger.finest("getFeatureAt " + seqpos + " " + lineNr);
        Segment s = getSegmentUnder(seqpos,lineNr);
        if (s == null ) 
            return null;
        
        return s.getParent();
        
    }
    
    
    /** check if mouse is over a segment and if it is, return the segment */
    private Segment getSegmentUnder( int seqpos,int lineNr){
        //logger.entering(this.getClass().getName(),"getSegmentUnder", new Object[]{new Integer(seqpos),new Integer(lineNr)});
        if ( ( lineNr < 0) || ( lineNr >= drawLines.size() ) ){
            return null ;
        }
        
        Line currentLine = (Line)drawLines.get(lineNr);
        List features = currentLine.getFeatures(); 
        
        
        for ( int i =0; i<features.size();i++ ){
            Feature feature = (Feature) features.get(i) ;
            List segments = feature.getSegments() ;
            for ( int j =0; j< segments.size() ; j++ ) {
                
                Segment segment = (Segment) segments.get(j);
                int start = segment.getStart() -1 ;
                int end   = segment.getEnd()   -1 ;
                
                if ( (start <= seqpos) && (end >= seqpos) ) {
                    //logger.exiting(this.getClass().getName(),"getSegmentUnder", new Object[]{segment});
                    return segment ;
                }
            }
        }
        //logger.exiting(this.getClass().getName(),"getSegmentUnder", new Object[]{null});
        return null ;
    }
    
    
    /** create a tooltip string */
    private String getToolString(int seqpos, Segment segment){
        //logger.finest("getToolString");
        // current position is seqpos
        String toolstr = spice.getToolString(current_chainnumber,seqpos);
        
        //logger.finest("getToolString");
        
        Feature parent = segment.getParent() ;
        String method  = parent.getMethod() ;
        String type    = parent.getType() ;
        String note    = parent.getNote() ;
        
        int start = segment.getStart() -1 ; 
        int end   = segment.getEnd()   -1 ; 
        
        toolstr += " " + type + " start " + start + " end " + end + " Note:" + note; 
        
        //logger.finest(toolstr);
        
        //new ToolTip(toolstr, this);
        //this.repaint();
        
        return toolstr ;
        
    }
    
    /** test if the click was on the name of the feature */
    private boolean nameClicked(MouseEvent e) {
        int x = e.getX();
        if (x <= DEFAULT_X_START) {
            return true ;
        }
        return false ;
    }
    
    /** get the sequence position of the current mouse event */
    private int getSeqPos(MouseEvent e) {
        
        int x = e.getX();
        int y = e.getY();
        
        int seqpos =  java.lang.Math.round((x-DEFAULT_X_START)/scale) ;
        
        return seqpos  ;
    }	
    
    public void mouseMoved(MouseEvent e)
    {	
        
        //, int x, int y
        int seqpos = getSeqPos(e);
        int linenr = getLineNr(e);
        
        
        //int featurenr = get_featurenr(y); 
        
        if ( linenr < 0 ) return ;
        if ( seqpos < 0 ) return ; 
        
        
        // and the feature display
        
        //Feature feature = getFeatureAt(seqpos,linenr);
        
        Segment segment = getSegmentUnder(seqpos,linenr);
        if ( segment != null) {
            String toolstr = getToolString(seqpos,segment);
            //gfeat.drawString(toolstr,5,13);
            spice.showStatus(toolstr) ;
            // display ToolTip
            this.setToolTipText(toolstr);
            
            /*
            Feature feat = segment.getParent();
            String link = feat.getLink();
            
            //logger.finest(segment);
            if (link != null ) {
                // check if this feature has a link, if yes,
                // change mouse cursor
                System.out.println("setting cursor to hand cursor");
                addLinkMenu(link);      
                setCursor(handCursor);
            } else {
                System.out.println("setting cursor to default cursor");
                setCursor(defaultCursor);
                removeLinkMenu();
            }
            */
            
        } else {
            this.setToolTipText(null);
            setCursor(defaultCursor);
            spice.showSeqPos(current_chainnumber,seqpos);
            
        }
          
        
        
        // slowing down the whole thing?
        
        
        
        if ( spice.isSelectionLocked()) 
            return;
        
        // disabled Jmol - slows down things a lot...
        spice.select(current_chainnumber,seqpos);
        return  ;
    }
    
    
    
    
    public void mouseClicked(MouseEvent e)
    {

        int seqpos = getSeqPos(e);
        int lineNr = getLineNr(e);
        if ( seqpos    > chain.getLength()) return ;
        
        int b = e.getButton();
        if ( b == MouseEvent.BUTTON3) {
          
            return;
        }           
        
        if ( b == MouseEvent.BUTTON1 && ( ! spice.isSelectionLocked()))
        {
            if ( lineNr < 0 ) return ;
            if ( seqpos < 0 ) {
                // check if the name was clicked
                if (nameClicked(e)){
                    // highlight all features in the line
                    //Feature feature = getFeatureAt(seqpos,lineNr);
                    Line currentLine = (Line)drawLines.get(lineNr);
                    List features = currentLine.getFeatures(); 
                    
                    String cmd = "";
                    for ( int i=0; i<features.size(); i++) {
                        Feature feature = (Feature) features.get(i);
                        cmd += highliteFeature(feature);		    
                    }
                    //logger.finest(cmd);
                    spice.executeCmd(cmd);
                    return  ;
                }
            }            
        }
       
        String drstr = "x "+ seqpos + " y " + lineNr ;
        
        spice.showStatus(drstr);
        Segment segment = getSegmentUnder(seqpos,lineNr);
        //logger.finest(segment);
        if (segment != null ) {
            if (! spice.isSelectionLocked() )
            highliteSegment(segment);
            
            
            String toolstr = getToolString(seqpos,segment);
            spice.showStatus(drstr + " " + toolstr) ;
            this.setToolTipText(toolstr);
            
            
        } else {
            if ( ! spice.isSelectionLocked())
                spice.highlite(current_chainnumber,seqpos);
            this.setToolTipText(null);
        }
       
        return  ;
    }	
    
    public void mouseEntered(MouseEvent e)  {}
    public void mouseExited(MouseEvent e)   {}
    
    
    public void mousePressed(MouseEvent e)  {
        	int b = e.getButton();
        	if ( b == MouseEvent.BUTTON1 )
            mouseDragStart = getSeqPos(e);
        
    }
    public void mouseReleased(MouseEvent e) {
        int b = e.getButton();
        if ( b == MouseEvent.BUTTON1 )
            mouseDragStart =  -1 ;
        
        // remove the link button from poopup
        //if ( popupMenu.getComponentCount() > 1) {
          //  removeLinkMenu();
        //}
    }
    public void mouseDragged(MouseEvent e) {
        //System.out.println("dragging mouse "+e);
        if ( mouseDragStart < 0 )
            return ;        
        
        int seqpos = getSeqPos(e);
       
        if (spice.isSelectionLocked())
            return;
        int selEnd =  seqpos;
        int start = mouseDragStart ;
        int end   = selEnd         ;
        if ( selEnd < mouseDragStart ) {
            start = selEnd ;
            end = mouseDragStart ;
        }
        spice.highlite(current_chainnumber,start,end);
    }
  
}



